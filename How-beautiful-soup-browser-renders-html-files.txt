The discrepancy you're observing—where the newline character (`\n`) is not visible when viewing the page source in a browser but is detected when parsing the HTML with BeautifulSoup in Python—can be explained by understanding how browsers and BeautifulSoup process and interpret HTML content. 

1. How Browsers Display Page Source:
When you view the page source of an HTML file in a browser (e.g., by right-clicking and selecting "View Page Source" in Chrome or Firefox), the browser shows the raw HTML content as it was received from the server or loaded from the file. However, browsers handle whitespace (including newlines, tabs, and extra spaces) in a specific way:

- Whitespace Normalization in HTML: HTML parsers in browsers collapse multiple whitespace characters (spaces, tabs, newlines) into a single space for rendering purposes, unless the content is within a `<pre>` tag or styled with CSS to preserve whitespace (e.g., `white-space: pre`). This is defined by the HTML specification, which treats newlines and other whitespace characters as "insignificant" for rendering unless they affect the document's structure or content.

- Page Source View: When you view the page source, you're seeing the raw HTML as it exists in the file or as sent by the server. However, the browser's source viewer may visually format the HTML for readability, which can make it seem like newlines are absent or not explicitly shown as `\n`. For example:
  - In the provided `three_sisters.html`, the HTML contains newlines (e.g., between `<head>` and `<body>`, or between `<p>` tags), but when viewed in the browser's source view, these newlines may not be explicitly highlighted or may appear as line breaks in the source viewer's rendering, not as literal `\n` characters.
  - The browser's source view doesn't display control characters like `\n` explicitly; it shows the file's line breaks as they are.

2. How BeautifulSoup Processes HTML
BeautifulSoup, a Python library for parsing HTML and XML, processes the HTML content differently and provides a more detailed view of the document's structure, including text nodes and whitespace:

- Parsing with BeautifulSoup: When you parse the HTML file using BeautifulSoup (e.g., with the `lxml` parser as in your code), the library builds a parse tree that represents every element, attribute, and text node in the document. This includes navigable strings, which are text content between tags, including whitespace like newlines (`\n`).

- Newline Characters as Navigable Strings: In the HTML document, newlines that appear between tags (e.g., between the closing `</p>` of the first paragraph and the opening `<p>` of the second paragraph) are treated as text nodes by BeautifulSoup. For example, in your HTML:
  ```html
  </p>
  <p>...</p>
  ```
  The newline character between `</p>` and `<p>...</p>` is parsed as a `NavigableString` containing `\n`. When you iterate over elements like `previous_siblings` (as in our code), BeautifulSoup includes these text nodes, which is why you see `\n` in your Python output.
  
- Parser Sensitivity: The parser used by BeautifulSoup (e.g., `lxml`, `html.parser`, or `html5lib`) can affect how whitespace is handled. The `lxml` parser, which we used, is precise and preserves whitespace nodes like newlines as part of the document tree. This makes newline characters explicitly visible when you access text nodes or siblings in your Python code.

3. Why You See `\n` in BeautifulSoup but Not in Browser Source
The key reasons for the discrepancy are:

- Representation in Python: When you print or inspect elements in BeautifulSoup (e.g., `sibling` in your loop), Python represents newline characters as the escaped string `\n` in the output. This is a Python convention for displaying control characters in strings. For example, if a text node contains a newline, printing it in Python will show `\n` explicitly.

- Browser Source View: The browser's page source view shows the raw HTML, but it doesn't highlight control characters like `\n`. Instead, newlines appear as actual line breaks in the source viewer's display. For instance, in your HTML:
  ```html
  <p>...</p>
  ```
  If there's a newline after `</p>`, it will cause the next `<p>` tag to appear on a new line in the source view, but you won't see `\n` as a literal string because the browser doesn't escape it—it just renders the line break visually.
  
- DOM vs. Source: When the browser parses HTML to build the Document Object Model (DOM), it may ignore or normalize insignificant whitespace for rendering purposes. However, BeautifulSoup's parse tree is more granular and includes all text nodes, including those containing only whitespace or newlines, which are preserved and accessible in Python.

### 4. Example from our Code
In our code, we're iterating over `previous_siblings` of a `<p>` tag (assumed to be the second `<p>` tag containing `...` for context). The HTML structure is:

```html
<body>
    <p>Once upon a time there were three little sisters; and their names were
        <a>Elsie</a>,
        <a>Lacie</a> and
        <a>Tillie</a>; and they lived at the bottom of a well.
    </p>
    <p>...</p>
</body>
```

- If you select the second `<p>` tag (`<p>...</p>`), its `previous_siblings` include:
  - A text node containing a newline (`\n`) between the first `</p>` and the second `<p>`.
  - The first `<p>` tag.
- When your loop runs:
  ```python
  for sibling in p.previous_siblings:
      print(sibling if sibling != '\n' else '')
  ```
  - For the text node containing `\n`, the condition `sibling != '\n'` is `False` (since the sibling is a `NavigableString` containing `\n`), so it prints an empty string (`''`).
  - For the first `<p>` tag, it prints the tag's contents.
- In Python, when you print a `NavigableString` containing a newline, it appears as `\n` in the output (e.g., `print(soup.find_all(text=True))` would show `\n` for newline text nodes). This explicit representation in Python makes newlines visible, unlike the browser's source view, where they are rendered as line breaks.

### 5. How to Verify Newlines in Browser Source
To confirm that newlines exist in the HTML source:
- Save the File: Ensure the HTML file (`three_sisters.html`) has newlines by opening it in a text editor (e.g., Notepad++, VS Code, or any editor that shows control characters). You should see line breaks between tags, which are encoded as `\n` (or `\r\n` on Windows).
- Browser Developer Tools: Instead of relying on the source view, use the browser's Developer Tools (F12) to inspect the DOM. However, note that the DOM may not show insignificant whitespace nodes, as browsers optimize them out for rendering. To see raw new '-', use a text editor or a tool like `curl` or `wget` to view the file's raw content.
- Python File Reading: You can read the file directly in Python to see newlines:
  ```python
  with open('three_sisters.html', 'r') as file:
      print(repr(file.read()))
  ```
  This will show `\n` for newlines, confirming they exist in the file.

### 6. Why This Matters
- Browser Rendering: Browsers ignore newlines and extra whitespace for rendering (unless in specific contexts like `<pre>`), so they don't affect the displayed page. This is why you don't "see" newlines impacting the browser's output.
- BeautifulSoup's Use Case: BeautifulSoup is designed for scraping and parsing, so it preserves all text nodes, including whitespace, to allow precise navigation of the document structure. This is why newlines are explicitly visible as `\n` in your Python output.
- Practical Implication: When writing code with BeautifulSoup, you often need to handle whitespace text nodes (e.g., by filtering out `\n` as you did in your loop) to avoid processing insignificant content.

Takeaway:
You see the newline character (`\n`) in BeautifulSoup because it parses the HTML into a tree that includes all text nodes, including those containing only newlines, and Python explicitly represents these as `\n` in output. In contrast, when viewing the page source in a browser, newlines are present but appear as line breaks in the source viewer's display, not as literal `\n` characters, because browsers don't escape control characters. To confirm newlines in the source, check the raw file in a text editor or use Python's `repr()` to see the escaped characters. This difference arises from BeautifulSoup's granular parsing versus the browser's rendering-focused HTML processing.